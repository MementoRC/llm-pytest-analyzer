# Task ID: 6
# Title: Implement Configuration System for Environment Manager Overrides
# Status: pending
# Dependencies: 5
# Priority: medium
# Description: Extend the existing configuration system to support manual overrides of environment manager detection
# Details:
Extend the configuration system to allow users to manually specify which environment manager to use:

```python
from pathlib import Path
from typing import Optional, Dict, Any
import json
import os

class Configuration:
    def __init__(self):
        self.config: Dict[str, Any] = {}
        self.loaded = False

    def load(self, project_path: Path) -> None:
        """Load configuration from project and user config files"""
        # Load global config
        user_config_path = Path.home() / ".pytest-analyzer" / "config.json"
        if user_config_path.exists():
            with open(user_config_path, 'r') as f:
                self.config.update(json.load(f))

        # Load project config (overrides global)
        project_config_path = project_path / ".pytest-analyzer.json"
        if project_config_path.exists():
            with open(project_config_path, 'r') as f:
                self.config.update(json.load(f))

        # Load environment variables (override files)
        env_manager = os.environ.get("PYTEST_ANALYZER_ENV_MANAGER")
        if env_manager:
            self.config["environment_manager"] = env_manager

        self.loaded = True

    def get_environment_manager_override(self) -> Optional[str]:
        """Get the manually specified environment manager, if any"""
        return self.config.get("environment_manager")
```

Update the CLI module to use this configuration:

```python
class CLI:
    def __init__(self):
        self.detector = EnvironmentManagerDetector()
        self.config = Configuration()
        self.current_manager: Optional[EnvironmentManager] = None

    def initialize(self, project_path: Path) -> None:
        """Initialize the CLI with the appropriate environment manager"""
        # Load configuration
        self.config.load(project_path)

        # Check for override
        override = self.config.get_environment_manager_override()
        if override:
            # Use the specified manager
            self.current_manager = self._get_manager_by_name(override, project_path)
        else:
            # Auto-detect
            self.current_manager = self.detector.detect(project_path)

    def _get_manager_by_name(self, name: str, project_path: Path) -> Optional[EnvironmentManager]:
        """Get an environment manager by name"""
        # Map names to manager classes
        managers = {
            "pixi": PixiManager,
            "poetry": PoetryManager,
            "hatch": HatchManager,
            "uv": UVManager,
            "pipenv": PipenvManager,
            "pip+venv": PipVenvManager
        }

        manager_cls = managers.get(name.lower())
        if manager_cls:
            return manager_cls(project_path)
        return None
```

# Test Strategy:
Create unit tests for the configuration system with mock configuration files. Test loading from different sources (global, project, environment variables). Test priority of configuration sources. Test integration with the CLI module to ensure overrides work correctly.
