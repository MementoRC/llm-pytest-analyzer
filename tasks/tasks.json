{
  "tasks": [
    {
      "id": 1,
      "title": "Create Environment Manager Protocol Interface",
      "description": "Define a protocol-based interface that specifies common operations for all environment managers",
      "details": "Create a Python protocol class that defines the interface for all environment managers. This should include methods for:\n- Detecting if the environment manager is used in the project\n- Building commands with proper environment context\n- Executing commands within the environment\n- Activating/deactivating environments\n\nExample implementation:\n```python\nfrom typing import Protocol, List, Optional\nfrom pathlib import Path\n\nclass EnvironmentManager(Protocol):\n    @classmethod\n    def detect(cls, project_path: Path) -> bool:\n        \"\"\"Detect if this environment manager is used in the project\"\"\"\n        ...\n        \n    def build_command(self, command: List[str]) -> List[str]:\n        \"\"\"Build a command with proper environment context\"\"\"\n        ...\n        \n    def execute_command(self, command: List[str]) -> int:\n        \"\"\"Execute a command within the environment\"\"\"\n        ...\n        \n    def activate(self) -> None:\n        \"\"\"Activate the environment\"\"\"\n        ...\n        \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the environment\"\"\"\n        ...\n```",
      "testStrategy": "Create unit tests for the protocol interface to ensure it defines all required methods. Use mypy to verify type checking works correctly with the protocol. Test with mock implementations to ensure the protocol can be properly implemented.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement Environment Manager Detection Service",
      "description": "Create a service that detects which environment manager is being used in a project based on project files",
      "details": "Implement a detection service that examines project files to determine which environment manager is in use:\n\n```python\nfrom pathlib import Path\nfrom typing import Optional, Type, List\nimport toml\n\nfrom .protocol import EnvironmentManager\nfrom .managers import PixiManager, PoetryManager, HatchManager, UVManager, PipenvManager, PipVenvManager\n\nclass EnvironmentManagerDetector:\n    def __init__(self):\n        self._managers: List[Type[EnvironmentManager]] = [\n            PixiManager,\n            PoetryManager,\n            HatchManager,\n            UVManager,\n            PipenvManager,\n            PipVenvManager\n        ]\n        self._cache = {}\n        \n    def detect(self, project_path: Path) -> Optional[EnvironmentManager]:\n        \"\"\"Detect and return the appropriate environment manager for the project\"\"\"\n        # Check cache first\n        if project_path in self._cache:\n            return self._cache[project_path]\n            \n        # Try each manager\n        for manager_cls in self._managers:\n            if manager_cls.detect(project_path):\n                manager = manager_cls(project_path)\n                self._cache[project_path] = manager\n                return manager\n                \n        return None\n```\n\nEnsure the detection logic follows the specified rules in the PRD:\n- Pixi: Check for pixi.toml file\n- Poetry: Check for pyproject.toml with [tool.poetry] section\n- Hatch: Check for pyproject.toml with [tool.hatch] section\n- UV: Check for uv.lock file or pyproject.toml with UV configuration\n- Pipenv: Check for Pipfile or Pipfile.lock\n- Pip+Venv: Check for requirements.txt with virtual environment",
      "testStrategy": "Create unit tests with mock file systems to test detection of each environment manager. Include tests for edge cases like multiple environment managers present, no environment managers, and invalid configurations. Test caching behavior to ensure it works correctly.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Pixi Environment Manager",
      "description": "Create a concrete implementation of the Environment Manager protocol for Pixi",
      "details": "Implement the Pixi environment manager class that conforms to the EnvironmentManager protocol:\n\n```python\nfrom pathlib import Path\nfrom typing import List\nimport subprocess\n\nfrom .protocol import EnvironmentManager\n\nclass PixiManager:\n    @classmethod\n    def detect(cls, project_path: Path) -> bool:\n        \"\"\"Detect if Pixi is used in the project\"\"\"\n        return (project_path / \"pixi.toml\").exists()\n        \n    def __init__(self, project_path: Path):\n        self.project_path = project_path\n        \n    def build_command(self, command: List[str]) -> List[str]:\n        \"\"\"Build a command with proper Pixi environment context\"\"\"\n        return [\"pixi\", \"run\"] + command\n        \n    def execute_command(self, command: List[str]) -> int:\n        \"\"\"Execute a command within the Pixi environment\"\"\"\n        full_command = self.build_command(command)\n        return subprocess.call(full_command, cwd=self.project_path)\n        \n    def activate(self) -> None:\n        \"\"\"Activate the Pixi environment (not typically needed as pixi run handles this)\"\"\"\n        pass\n        \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the Pixi environment\"\"\"\n        pass\n```\n\nEnsure the implementation correctly handles Pixi-specific command execution patterns and environment activation.",
      "testStrategy": "Create unit tests that verify the Pixi manager correctly detects Pixi projects, builds commands properly, and executes commands in the Pixi environment. Mock subprocess calls to verify correct command construction. Test with actual Pixi projects in integration tests.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Poetry, Hatch, UV, Pipenv, and Pip+Venv Managers",
      "description": "Create concrete implementations of the Environment Manager protocol for all other supported environment managers",
      "details": "Implement the remaining environment manager classes following the same pattern as the Pixi manager. Each implementation should:\n\n1. Correctly detect its environment based on project files\n2. Build commands appropriately for that environment\n3. Execute commands in the correct environment context\n\nFor example, the Poetry implementation might look like:\n\n```python\nclass PoetryManager:\n    @classmethod\n    def detect(cls, project_path: Path) -> bool:\n        \"\"\"Detect if Poetry is used in the project\"\"\"\n        pyproject_path = project_path / \"pyproject.toml\"\n        if not pyproject_path.exists():\n            return False\n            \n        try:\n            with open(pyproject_path, 'r') as f:\n                config = toml.load(f)\n                return 'tool' in config and 'poetry' in config['tool']\n        except Exception:\n            return False\n        \n    def __init__(self, project_path: Path):\n        self.project_path = project_path\n        \n    def build_command(self, command: List[str]) -> List[str]:\n        \"\"\"Build a command with proper Poetry environment context\"\"\"\n        return [\"poetry\", \"run\"] + command\n        \n    def execute_command(self, command: List[str]) -> int:\n        \"\"\"Execute a command within the Poetry environment\"\"\"\n        full_command = self.build_command(command)\n        return subprocess.call(full_command, cwd=self.project_path)\n        \n    def activate(self) -> None:\n        \"\"\"Activate the Poetry environment\"\"\"\n        subprocess.call([\"poetry\", \"shell\"], cwd=self.project_path)\n        \n    def deactivate(self) -> None:\n        \"\"\"Deactivate the Poetry environment\"\"\"\n        # Exit the shell or use the appropriate deactivation command\n        pass\n```\n\nImplement similar classes for Hatch, UV, Pipenv, and Pip+Venv, each with their specific detection logic and command execution patterns.",
      "testStrategy": "Create unit tests for each environment manager implementation. Test detection logic with various project structures. Test command building and execution with mocked subprocess calls. Create integration tests with sample projects for each environment manager type.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Integrate Environment Manager Detection into CLI Module",
      "description": "Update the existing CLI module to use the environment manager detection service for command execution",
      "details": "Modify the existing CLI module to use the environment manager detection service:\n\n```python\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom .detection import EnvironmentManagerDetector\nfrom .protocol import EnvironmentManager\n\nclass CLI:\n    def __init__(self):\n        self.detector = EnvironmentManagerDetector()\n        self.current_manager: Optional[EnvironmentManager] = None\n        \n    def initialize(self, project_path: Path) -> None:\n        \"\"\"Initialize the CLI with the appropriate environment manager\"\"\"\n        self.current_manager = self.detector.detect(project_path)\n        \n    def execute_command(self, command: list[str], project_path: Path) -> int:\n        \"\"\"Execute a command using the appropriate environment manager\"\"\"\n        if not self.current_manager:\n            self.initialize(project_path)\n            \n        if self.current_manager:\n            return self.current_manager.execute_command(command)\n        else:\n            # Fall back to direct execution if no environment manager is detected\n            import subprocess\n            return subprocess.call(command, cwd=project_path)\n```\n\nEnsure that the CLI maintains backward compatibility with existing behavior while adding the new environment manager detection functionality.",
      "testStrategy": "Create unit tests for the CLI module with mocked environment managers. Test initialization and command execution with different environment managers. Test fallback behavior when no environment manager is detected. Create integration tests that verify end-to-end functionality with real commands.",
      "priority": "high",
      "dependencies": [
        2,
        3,
        4
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Configuration System for Environment Manager Overrides",
      "description": "Extend the existing configuration system to support manual overrides of environment manager detection",
      "details": "Extend the configuration system to allow users to manually specify which environment manager to use:\n\n```python\nfrom pathlib import Path\nfrom typing import Optional, Dict, Any\nimport json\nimport os\n\nclass Configuration:\n    def __init__(self):\n        self.config: Dict[str, Any] = {}\n        self.loaded = False\n        \n    def load(self, project_path: Path) -> None:\n        \"\"\"Load configuration from project and user config files\"\"\"\n        # Load global config\n        user_config_path = Path.home() / \".pytest-analyzer\" / \"config.json\"\n        if user_config_path.exists():\n            with open(user_config_path, 'r') as f:\n                self.config.update(json.load(f))\n                \n        # Load project config (overrides global)\n        project_config_path = project_path / \".pytest-analyzer.json\"\n        if project_config_path.exists():\n            with open(project_config_path, 'r') as f:\n                self.config.update(json.load(f))\n                \n        # Load environment variables (override files)\n        env_manager = os.environ.get(\"PYTEST_ANALYZER_ENV_MANAGER\")\n        if env_manager:\n            self.config[\"environment_manager\"] = env_manager\n            \n        self.loaded = True\n        \n    def get_environment_manager_override(self) -> Optional[str]:\n        \"\"\"Get the manually specified environment manager, if any\"\"\"\n        return self.config.get(\"environment_manager\")\n```\n\nUpdate the CLI module to use this configuration:\n\n```python\nclass CLI:\n    def __init__(self):\n        self.detector = EnvironmentManagerDetector()\n        self.config = Configuration()\n        self.current_manager: Optional[EnvironmentManager] = None\n        \n    def initialize(self, project_path: Path) -> None:\n        \"\"\"Initialize the CLI with the appropriate environment manager\"\"\"\n        # Load configuration\n        self.config.load(project_path)\n        \n        # Check for override\n        override = self.config.get_environment_manager_override()\n        if override:\n            # Use the specified manager\n            self.current_manager = self._get_manager_by_name(override, project_path)\n        else:\n            # Auto-detect\n            self.current_manager = self.detector.detect(project_path)\n            \n    def _get_manager_by_name(self, name: str, project_path: Path) -> Optional[EnvironmentManager]:\n        \"\"\"Get an environment manager by name\"\"\"\n        # Map names to manager classes\n        managers = {\n            \"pixi\": PixiManager,\n            \"poetry\": PoetryManager,\n            \"hatch\": HatchManager,\n            \"uv\": UVManager,\n            \"pipenv\": PipenvManager,\n            \"pip+venv\": PipVenvManager\n        }\n        \n        manager_cls = managers.get(name.lower())\n        if manager_cls:\n            return manager_cls(project_path)\n        return None\n```",
      "testStrategy": "Create unit tests for the configuration system with mock configuration files. Test loading from different sources (global, project, environment variables). Test priority of configuration sources. Test integration with the CLI module to ensure overrides work correctly.",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement CLI Flags for Environment Manager Override",
      "description": "Add command-line flags to allow users to override the environment manager detection",
      "details": "Extend the CLI argument parsing to support environment manager override flags:\n\n```python\nimport argparse\nfrom pathlib import Path\n\nclass CLIParser:\n    def __init__(self):\n        self.parser = argparse.ArgumentParser(description=\"pytest-analyzer CLI\")\n        self._configure_parser()\n        \n    def _configure_parser(self) -> None:\n        \"\"\"Configure the argument parser\"\"\"\n        # Existing arguments...\n        \n        # Add environment manager group\n        env_group = self.parser.add_argument_group(\"Environment Manager\")\n        env_group.add_argument(\n            \"--env-manager\",\n            choices=[\"auto\", \"pixi\", \"poetry\", \"hatch\", \"uv\", \"pipenv\", \"pip+venv\"],\n            default=\"auto\",\n            help=\"Specify the environment manager to use (default: auto-detect)\"\n        )\n        \n    def parse(self, args=None):\n        \"\"\"Parse command-line arguments\"\"\"\n        return self.parser.parse_args(args)\n```\n\nUpdate the CLI module to use these flags:\n\n```python\nclass CLI:\n    def __init__(self):\n        self.detector = EnvironmentManagerDetector()\n        self.config = Configuration()\n        self.parser = CLIParser()\n        self.current_manager: Optional[EnvironmentManager] = None\n        \n    def run(self, args=None) -> int:\n        \"\"\"Run the CLI with the given arguments\"\"\"\n        parsed_args = self.parser.parse(args)\n        project_path = Path(parsed_args.project_path or \".\").absolute()\n        \n        # Load configuration\n        self.config.load(project_path)\n        \n        # Determine environment manager\n        if parsed_args.env_manager != \"auto\":\n            # CLI flag takes highest priority\n            self.current_manager = self._get_manager_by_name(parsed_args.env_manager, project_path)\n        else:\n            # Check config override\n            override = self.config.get_environment_manager_override()\n            if override:\n                self.current_manager = self._get_manager_by_name(override, project_path)\n            else:\n                # Auto-detect\n                self.current_manager = self.detector.detect(project_path)\n        \n        # Execute the command\n        command = self._build_command(parsed_args)\n        if self.current_manager:\n            return self.current_manager.execute_command(command)\n        else:\n            # Fall back to direct execution\n            import subprocess\n            return subprocess.call(command, cwd=project_path)\n```",
      "testStrategy": "Create unit tests for the CLI parser with various argument combinations. Test that environment manager flags are correctly parsed. Test integration with the CLI module to ensure flag-based overrides take precedence over configuration-based overrides.",
      "priority": "medium",
      "dependencies": [
        5,
        6
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Caching Mechanism for Detection Results",
      "description": "Create a caching system to avoid repeated file system operations during environment manager detection",
      "details": "Implement a more sophisticated caching mechanism for the environment manager detector:\n\n```python\nfrom pathlib import Path\nfrom typing import Dict, Optional, Type, Tuple\nimport time\nimport os\n\nfrom .protocol import EnvironmentManager\n\nclass EnvironmentManagerCache:\n    def __init__(self, max_size: int = 100, ttl: int = 300):\n        self.cache: Dict[Path, Tuple[EnvironmentManager, float, Dict[str, float]]] = {}\n        self.max_size = max_size  # Maximum number of entries\n        self.ttl = ttl  # Time-to-live in seconds\n        \n    def get(self, project_path: Path) -> Optional[EnvironmentManager]:\n        \"\"\"Get a cached environment manager if valid\"\"\"\n        if project_path not in self.cache:\n            return None\n            \n        manager, timestamp, file_mtimes = self.cache[project_path]\n        current_time = time.time()\n        \n        # Check if cache entry has expired\n        if current_time - timestamp > self.ttl:\n            del self.cache[project_path]\n            return None\n            \n        # Check if any relevant files have changed\n        for file_path, mtime in file_mtimes.items():\n            full_path = project_path / file_path\n            if full_path.exists() and os.path.getmtime(full_path) > mtime:\n                del self.cache[project_path]\n                return None\n                \n        return manager\n        \n    def set(self, project_path: Path, manager: EnvironmentManager) -> None:\n        \"\"\"Cache an environment manager\"\"\"\n        # Collect mtimes of relevant files\n        file_mtimes = {}\n        relevant_files = [\n            \"pixi.toml\", \"pyproject.toml\", \"Pipfile\", \"Pipfile.lock\",\n            \"requirements.txt\", \"uv.lock\"\n        ]\n        \n        for file_name in relevant_files:\n            file_path = project_path / file_name\n            if file_path.exists():\n                file_mtimes[file_name] = os.path.getmtime(file_path)\n                \n        # Add to cache with current timestamp\n        self.cache[project_path] = (manager, time.time(), file_mtimes)\n        \n        # Evict oldest entries if cache is too large\n        if len(self.cache) > self.max_size:\n            oldest_path = min(self.cache.keys(), key=lambda p: self.cache[p][1])\n            del self.cache[oldest_path]\n```\n\nUpdate the detector to use this cache:\n\n```python\nclass EnvironmentManagerDetector:\n    def __init__(self):\n        self._managers: List[Type[EnvironmentManager]] = [\n            PixiManager,\n            PoetryManager,\n            HatchManager,\n            UVManager,\n            PipenvManager,\n            PipVenvManager\n        ]\n        self._cache = EnvironmentManagerCache()\n        \n    def detect(self, project_path: Path) -> Optional[EnvironmentManager]:\n        \"\"\"Detect and return the appropriate environment manager for the project\"\"\"\n        # Check cache first\n        cached_manager = self._cache.get(project_path)\n        if cached_manager:\n            return cached_manager\n            \n        # Try each manager\n        for manager_cls in self._managers:\n            if manager_cls.detect(project_path):\n                manager = manager_cls(project_path)\n                self._cache.set(project_path, manager)\n                return manager\n                \n        return None\n```",
      "testStrategy": "Create unit tests for the caching mechanism with mock file systems. Test cache hits, misses, and invalidation based on file changes. Test time-based expiration. Test cache size limits and eviction policies. Measure performance improvements from caching in integration tests.",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Update Test Execution and Quality Validation Workflows",
      "description": "Modify existing test execution and quality validation workflows to use the detected environment manager",
      "details": "Update the test execution and quality validation workflows to use the environment manager detection:\n\n```python\nfrom pathlib import Path\nfrom typing import List, Optional\n\nfrom .cli import CLI\n\nclass TestExecutor:\n    def __init__(self):\n        self.cli = CLI()\n        \n    def initialize(self, project_path: Path) -> None:\n        \"\"\"Initialize the test executor with the appropriate environment manager\"\"\"\n        self.cli.initialize(project_path)\n        \n    def run_tests(self, test_paths: List[str], project_path: Path, options: List[str] = None) -> int:\n        \"\"\"Run pytest with the appropriate environment manager\"\"\"\n        if options is None:\n            options = []\n            \n        command = [\"pytest\"] + options + test_paths\n        return self.cli.execute_command(command, project_path)\n        \n    def run_linter(self, paths: List[str], project_path: Path, options: List[str] = None) -> int:\n        \"\"\"Run ruff with the appropriate environment manager\"\"\"\n        if options is None:\n            options = []\n            \n        command = [\"ruff\", \"check\"] + options + paths\n        return self.cli.execute_command(command, project_path)\n        \n    def run_pre_commit(self, project_path: Path) -> int:\n        \"\"\"Run pre-commit with the appropriate environment manager\"\"\"\n        command = [\"pre-commit\", \"run\", \"--all-files\"]\n        return self.cli.execute_command(command, project_path)\n```\n\nEnsure that all quality validation commands are executed within the correct environment context.",
      "testStrategy": "Create unit tests for the test executor with mocked CLI and environment managers. Test that commands are correctly built and executed for different quality tools. Create integration tests that verify end-to-end functionality with real commands and environment managers.",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Update Documentation and Create Examples",
      "description": "Update project documentation to include information about environment manager detection and create examples for each supported manager",
      "details": "Update the project documentation to include information about the environment manager detection feature:\n\n1. Update README.md with a new section on environment manager support\n2. Create a detailed documentation page explaining how the detection works\n3. Document configuration options for environment manager overrides\n4. Document CLI flags for environment manager selection\n5. Create examples for each supported environment manager\n\nExample README section:\n\n```markdown\n## Environment Manager Support\n\npytest-analyzer now automatically detects and integrates with your project's Python environment manager:\n\n- **Pixi**: Automatically detected via `pixi.toml`\n- **Poetry**: Automatically detected via `pyproject.toml` with `[tool.poetry]`\n- **Hatch**: Automatically detected via `pyproject.toml` with `[tool.hatch]`\n- **UV**: Automatically detected via `uv.lock` or UV configuration in `pyproject.toml`\n- **Pipenv**: Automatically detected via `Pipfile` or `Pipfile.lock`\n- **Pip+Venv**: Automatically detected via `requirements.txt` with virtual environment\n\n### Manual Override\n\nYou can manually specify which environment manager to use:\n\n```bash\n# Via CLI flag\npytest-analyzer --env-manager poetry\n\n# Via configuration file (.pytest-analyzer.json)\n{\n  \"environment_manager\": \"poetry\"\n}\n\n# Via environment variable\nPYTEST_ANALYZER_ENV_MANAGER=poetry pytest-analyzer\n```\n```\n\nCreate example projects for each environment manager in the `examples/` directory to demonstrate usage.",
      "testStrategy": "Review documentation for accuracy and completeness. Test examples to ensure they work correctly with each environment manager. Conduct user testing to verify that the documentation is clear and helpful.",
      "priority": "low",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}
