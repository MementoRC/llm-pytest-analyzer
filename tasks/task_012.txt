# Task ID: 12
# Title: Implement Error Handling Mechanism
# Status: pending
# Dependencies: None
# Priority: medium
# Description: Establish a consistent error handling mechanism throughout the codebase
# Details:
Implement a consistent error handling mechanism. Create custom exception classes, context managers for resource handling, and standardized error reporting.

Example implementation:
```python
import logging
from typing import Optional, Type, TypeVar, Generic, Callable, Any
from contextlib import contextmanager

# Custom exceptions
class PytestAnalyzerError(Exception):
    """Base exception for all pytest-analyzer errors"""
    pass

class ExtractionError(PytestAnalyzerError):
    """Error during test failure extraction"""
    pass

class AnalysisError(PytestAnalyzerError):
    """Error during test failure analysis"""
    pass

class SuggestionError(PytestAnalyzerError):
    """Error during fix suggestion"""
    pass

class ApplicationError(PytestAnalyzerError):
    """Error during fix application"""
    pass

class LLMServiceError(PytestAnalyzerError):
    """Error during LLM service interaction"""
    pass

# Error context manager
T = TypeVar('T')

class ErrorHandler(Generic[T]):
    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)

    @contextmanager
    def handle_errors(self, operation: str, error_type: Type[PytestAnalyzerError] = PytestAnalyzerError):
        try:
            yield
        except error_type as e:
            self.logger.error(f"{operation} failed: {str(e)}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error during {operation}: {str(e)}")
            raise error_type(f"Unexpected error during {operation}: {str(e)}") from e

    def retry(self, operation: str, max_retries: int = 3,
              error_type: Type[PytestAnalyzerError] = PytestAnalyzerError,
              should_retry: Callable[[Exception], bool] = lambda _: True):
        def decorator(func):
            def wrapper(*args, **kwargs):
                last_exception = None

                for attempt in range(max_retries):
                    try:
                        return func(*args, **kwargs)
                    except Exception as e:
                        last_exception = e
                        if not should_retry(e) or attempt >= max_retries - 1:
                            break

                        self.logger.warning(f"{operation} attempt {attempt+1} failed: {str(e)}")

                # If we get here, all retries failed
                self.logger.error(f"{operation} failed after {max_retries} attempts")
                if isinstance(last_exception, PytestAnalyzerError):
                    raise last_exception
                else:
                    raise error_type(f"{operation} failed: {str(last_exception)}") from last_exception

            return wrapper
        return decorator
```

Ensure the implementation provides consistent error handling and reporting throughout the codebase.

# Test Strategy:
Create unit tests to verify error handling in various scenarios. Test the context manager with different types of exceptions. Test the retry decorator with both recoverable and non-recoverable errors. Verify that custom exceptions are properly raised and contain appropriate context information.
