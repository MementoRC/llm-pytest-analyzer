# Task ID: 8
# Title: Implement Caching Mechanism for Detection Results
# Status: done
# Dependencies: 2
# Priority: medium
# Description: Create a caching system to avoid repeated file system operations during environment manager detection
# Details:
Implement a more sophisticated caching mechanism for the environment manager detector:

```python
from pathlib import Path
from typing import Dict, Optional, Type, Tuple
import time
import os

from .protocol import EnvironmentManager

class EnvironmentManagerCache:
    def __init__(self, max_size: int = 100, ttl: int = 300):
        self.cache: Dict[Path, Tuple[EnvironmentManager, float, Dict[str, float]]] = {}
        self.max_size = max_size  # Maximum number of entries
        self.ttl = ttl  # Time-to-live in seconds

    def get(self, project_path: Path) -> Optional[EnvironmentManager]:
        """Get a cached environment manager if valid"""
        if project_path not in self.cache:
            return None

        manager, timestamp, file_mtimes = self.cache[project_path]
        current_time = time.time()

        # Check if cache entry has expired
        if current_time - timestamp > self.ttl:
            del self.cache[project_path]
            return None

        # Check if any relevant files have changed
        for file_path, mtime in file_mtimes.items():
            full_path = project_path / file_path
            if full_path.exists() and os.path.getmtime(full_path) > mtime:
                del self.cache[project_path]
                return None

        return manager

    def set(self, project_path: Path, manager: EnvironmentManager) -> None:
        """Cache an environment manager"""
        # Collect mtimes of relevant files
        file_mtimes = {}
        relevant_files = [
            "pixi.toml", "pyproject.toml", "Pipfile", "Pipfile.lock",
            "requirements.txt", "uv.lock"
        ]

        for file_name in relevant_files:
            file_path = project_path / file_name
            if file_path.exists():
                file_mtimes[file_name] = os.path.getmtime(file_path)

        # Add to cache with current timestamp
        self.cache[project_path] = (manager, time.time(), file_mtimes)

        # Evict oldest entries if cache is too large
        if len(self.cache) > self.max_size:
            oldest_path = min(self.cache.keys(), key=lambda p: self.cache[p][1])
            del self.cache[oldest_path]
```

Update the detector to use this cache:

```python
class EnvironmentManagerDetector:
    def __init__(self):
        self._managers: List[Type[EnvironmentManager]] = [
            PixiManager,
            PoetryManager,
            HatchManager,
            UVManager,
            PipenvManager,
            PipVenvManager
        ]
        self._cache = EnvironmentManagerCache()

    def detect(self, project_path: Path) -> Optional[EnvironmentManager]:
        """Detect and return the appropriate environment manager for the project"""
        # Check cache first
        cached_manager = self._cache.get(project_path)
        if cached_manager:
            return cached_manager

        # Try each manager
        for manager_cls in self._managers:
            if manager_cls.detect(project_path):
                manager = manager_cls(project_path)
                self._cache.set(project_path, manager)
                return manager

        return None
```

# Test Strategy:
Create unit tests for the caching mechanism with mock file systems. Test cache hits, misses, and invalidation based on file changes. Test time-based expiration. Test cache size limits and eviction policies. Measure performance improvements from caching in integration tests.
