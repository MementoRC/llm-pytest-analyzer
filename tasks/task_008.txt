# Task ID: 8
# Title: Implement Analyzer State Machine
# Status: done
# Dependencies: 2, 3, 4, 5, 6, 7
# Priority: high
# Description: Create a state machine implementation for the test analysis workflow.
# Details:
Implement a concrete state machine for the test analysis workflow:

```python
from enum import Enum, auto
from typing import Dict, Any, List, Optional

class AnalyzerState(Enum):
    INITIALIZE = auto()
    EXTRACT_TEST_RESULTS = auto()
    ANALYZE_FAILURES = auto()
    GENERATE_SUGGESTIONS = auto()
    APPLY_FIXES = auto()
    COMPLETE = auto()
    ERROR = auto()

class AnalyzerStateMachine(StateMachine[AnalyzerState]):
    def __init__(self, di_container: DIContainer):
        super().__init__(AnalyzerState.INITIALIZE)
        self.di_container = di_container
        
        # Register states
        self.add_state(AnalyzerState.INITIALIZE, self._initialize)
        self.add_state(AnalyzerState.EXTRACT_TEST_RESULTS, self._extract_test_results)
        self.add_state(AnalyzerState.ANALYZE_FAILURES, self._analyze_failures)
        self.add_state(AnalyzerState.GENERATE_SUGGESTIONS, self._generate_suggestions)
        self.add_state(AnalyzerState.APPLY_FIXES, self._apply_fixes)
        self.add_state(AnalyzerState.COMPLETE, self._complete)
        self.add_state(AnalyzerState.ERROR, self._handle_error)
        
        # Register transitions
        self.add_transition(
            AnalyzerState.INITIALIZE, 
            AnalyzerState.EXTRACT_TEST_RESULTS,
            lambda ctx, **kwargs: ctx.get('initialized', False)
        )
        self.add_transition(
            AnalyzerState.EXTRACT_TEST_RESULTS, 
            AnalyzerState.ANALYZE_FAILURES,
            lambda ctx, **kwargs: ctx.get('extraction_results') is not None
        )
        self.add_transition(
            AnalyzerState.ANALYZE_FAILURES, 
            AnalyzerState.GENERATE_SUGGESTIONS,
            lambda ctx, **kwargs: ctx.get('analysis_results') is not None
        )
        self.add_transition(
            AnalyzerState.GENERATE_SUGGESTIONS, 
            AnalyzerState.APPLY_FIXES,
            lambda ctx, **kwargs: ctx.get('suggestions') is not None and kwargs.get('apply_fixes', False)
        )
        self.add_transition(
            AnalyzerState.GENERATE_SUGGESTIONS, 
            AnalyzerState.COMPLETE,
            lambda ctx, **kwargs: ctx.get('suggestions') is not None and not kwargs.get('apply_fixes', False)
        )
        self.add_transition(
            AnalyzerState.APPLY_FIXES, 
            AnalyzerState.COMPLETE,
            lambda ctx, **kwargs: ctx.get('fixes_applied', False)
        )
        
        # Error transitions from any state
        for state in AnalyzerState:
            if state not in [AnalyzerState.COMPLETE, AnalyzerState.ERROR]:
                self.add_transition(
                    state,
                    AnalyzerState.ERROR,
                    lambda ctx, **kwargs: ctx.get('error') is not None
                )
    
    def _initialize(self, context: Dict[str, Any], **kwargs) -> None:
        try:
            # Initialize components
            context['extractor'] = self.di_container.resolve(Extractor)
            context['analyzer'] = self.di_container.resolve(Analyzer)
            context['suggester'] = self.di_container.resolve(Suggester)
            context['applier'] = self.di_container.resolve(Applier)
            context['initialized'] = True
        except Exception as e:
            context['error'] = str(e)
    
    def _extract_test_results(self, context: Dict[str, Any], **kwargs) -> None:
        try:
            extractor = context['extractor']
            test_results = kwargs.get('test_results')
            if not test_results:
                raise ValueError("No test results provided")
                
            context['extraction_results'] = extractor.extract(test_results)
        except Exception as e:
            context['error'] = str(e)
    
    def _analyze_failures(self, context: Dict[str, Any], **kwargs) -> None:
        try:
            analyzer = context['analyzer']
            extraction_results = context['extraction_results']
            context['analysis_results'] = analyzer.analyze(extraction_results)
        except Exception as e:
            context['error'] = str(e)
    
    def _generate_suggestions(self, context: Dict[str, Any], **kwargs) -> None:
        try:
            suggester = context['suggester']
            analysis_results = context['analysis_results']
            context['suggestions'] = suggester.suggest(analysis_results)
        except Exception as e:
            context['error'] = str(e)
    
    def _apply_fixes(self, context: Dict[str, Any], **kwargs) -> None:
        try:
            applier = context['applier']
            suggestions = context['suggestions']
            target_files = kwargs.get('target_files', [])
            context['fixes_applied'] = applier.apply(suggestions, target_files)
        except Exception as e:
            context['error'] = str(e)
    
    def _complete(self, context: Dict[str, Any], **kwargs) -> Dict[str, Any]:
        # Return the final results
        return {
            'extraction_results': context.get('extraction_results'),
            'analysis_results': context.get('analysis_results'),
            'suggestions': context.get('suggestions'),
            'fixes_applied': context.get('fixes_applied', False)
        }
    
    def _handle_error(self, context: Dict[str, Any], **kwargs) -> Dict[str, Any]:
        # Return error information
        return {
            'error': context.get('error', 'Unknown error'),
            'state': self.current_state.name,
            'partial_results': {
                'extraction_results': context.get('extraction_results'),
                'analysis_results': context.get('analysis_results'),
                'suggestions': context.get('suggestions')
            }
        }
```

This implementation should handle the complete workflow of extracting test results, analyzing failures, generating suggestions, and optionally applying fixes.

# Test Strategy:
Create unit tests that verify each state transition and handler. Use mocked dependencies to test both successful and error scenarios. Test the complete workflow with different input parameters.
