# Task ID: 14
# Title: Implement Comprehensive Error Handling
# Status: pending
# Dependencies: 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
# Priority: medium
# Description: Implement a consistent error handling mechanism throughout the codebase.
# Details:
Implement a consistent error handling mechanism:

```python
from typing import Dict, Any, Optional, Type, TypeVar, Generic
import logging
import traceback
from contextlib import contextmanager

T = TypeVar('T')

class PytestAnalyzerError(Exception):
    """Base exception class for pytest-analyzer errors."""
    def __init__(self, message: str, cause: Optional[Exception] = None):
        self.message = message
        self.cause = cause
        super().__init__(message)

class ConfigurationError(PytestAnalyzerError):
    """Error raised when there's a configuration issue."""
    pass

class ExtractionError(PytestAnalyzerError):
    """Error raised during test result extraction."""
    pass

class AnalysisError(PytestAnalyzerError):
    """Error raised during test failure analysis."""
    pass

class SuggestionError(PytestAnalyzerError):
    """Error raised during fix suggestion generation."""
    pass

class ApplicationError(PytestAnalyzerError):
    """Error raised during fix application."""
    pass

class LLMServiceError(PytestAnalyzerError):
    """Error raised during LLM service operations."""
    pass

class ErrorHandler:
    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger('pytest-analyzer')

    @contextmanager
    def handle_errors(self, error_type: Type[PytestAnalyzerError], operation: str, reraise: bool = True):
        """Context manager for handling errors in a consistent way."""
        try:
            yield
        except PytestAnalyzerError as e:
            # Already a known error type, just log and re-raise
            self.logger.error(f"{operation} failed: {e.message}")
            if e.cause:
                self.logger.debug(f"Caused by: {str(e.cause)}\n{traceback.format_exc()}")
            if reraise:
                raise
        except Exception as e:
            # Wrap unknown exceptions in the specified error type
            error_message = f"{operation} failed: {str(e)}"
            self.logger.error(error_message)
            self.logger.debug(f"Exception details: {traceback.format_exc()}")
            if reraise:
                raise error_type(error_message, e)

class ResultWithError(Generic[T]):
    """A container for operation results that might include errors."""
    def __init__(self, value: Optional[T] = None, error: Optional[PytestAnalyzerError] = None):
        self.value = value
        self.error = error

    @property
    def success(self) -> bool:
        return self.error is None

    def unwrap(self) -> T:
        """Get the value or raise the error if present."""
        if self.error:
            raise self.error
        return self.value

    def map(self, func):
        """Apply a function to the value if no error, otherwise return self."""
        if self.error:
            return self
        try:
            return ResultWithError(func(self.value))
        except Exception as e:
            if isinstance(e, PytestAnalyzerError):
                return ResultWithError(error=e)
            return ResultWithError(error=PytestAnalyzerError(str(e), e))
```

Update all components to use this error handling mechanism. For example, update the LLM service:

```python
class LLMService:
    def __init__(self, config: LLMConfig, error_handler: Optional[ErrorHandler] = None):
        self.config = config
        self.error_handler = error_handler or ErrorHandler()

    def generate(self, prompt: str, **kwargs) -> ResultWithError[str]:
        with self.error_handler.handle_errors(LLMServiceError, "LLM generation", reraise=False) as result:
            # Implementation for synchronous API call
            params = {**self.config.__dict__, **kwargs}
            response = requests.post(
                "https://api.openai.com/v1/completions",
                headers={"Authorization": f"Bearer {self.config.api_key}"},
                json={"prompt": prompt, **params}
            )
            response.raise_for_status()
            return ResultWithError(response.json()["choices"][0]["text"])

        # If we get here, there was an error
        return result

    async def generate_async(self, prompt: str, **kwargs) -> ResultWithError[str]:
        with self.error_handler.handle_errors(LLMServiceError, "Async LLM generation", reraise=False) as result:
            # Implementation for asynchronous API call
            params = {**self.config.__dict__, **kwargs}
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    "https://api.openai.com/v1/completions",
                    headers={"Authorization": f"Bearer {self.config.api_key}"},
                    json={"prompt": prompt, **params}
                ) as response:
                    if response.status != 200:
                        text = await response.text()
                        raise LLMServiceError(f"API error: {response.status}, {text}")
                    data = await response.json()
                    return ResultWithError(data["choices"][0]["text"])

        # If we get here, there was an error
        return result
```

Update other components similarly to use the error handling mechanism.

# Test Strategy:
Create unit tests for the error handling mechanism, including the context manager and ResultWithError class. Test error propagation through component chains. Verify that errors are properly logged and wrapped in the appropriate error types.
