# Task ID: 4
# Title: Implement Poetry, Hatch, UV, Pipenv, and Pip+Venv Managers
# Status: in-progress
# Dependencies: 1
# Priority: high
# Description: Create concrete implementations of the Environment Manager protocol for all other supported environment managers
# Details:
Implement the remaining environment manager classes following the same pattern as the Pixi manager. Each implementation should:

1. Correctly detect its environment based on project files
2. Build commands appropriately for that environment
3. Execute commands in the correct environment context

For example, the Poetry implementation might look like:

```python
class PoetryManager:
    @classmethod
    def detect(cls, project_path: Path) -> bool:
        """Detect if Poetry is used in the project"""
        pyproject_path = project_path / "pyproject.toml"
        if not pyproject_path.exists():
            return False

        try:
            with open(pyproject_path, 'r') as f:
                config = toml.load(f)
                return 'tool' in config and 'poetry' in config['tool']
        except Exception:
            return False

    def __init__(self, project_path: Path):
        self.project_path = project_path

    def build_command(self, command: List[str]) -> List[str]:
        """Build a command with proper Poetry environment context"""
        return ["poetry", "run"] + command

    def execute_command(self, command: List[str]) -> int:
        """Execute a command within the Poetry environment"""
        full_command = self.build_command(command)
        return subprocess.call(full_command, cwd=self.project_path)

    def activate(self) -> None:
        """Activate the Poetry environment"""
        subprocess.call(["poetry", "shell"], cwd=self.project_path)

    def deactivate(self) -> None:
        """Deactivate the Poetry environment"""
        # Exit the shell or use the appropriate deactivation command
        pass
```

Implement similar classes for Hatch, UV, Pipenv, and Pip+Venv, each with their specific detection logic and command execution patterns.

# Test Strategy:
Create unit tests for each environment manager implementation. Test detection logic with various project structures. Test command building and execution with mocked subprocess calls. Create integration tests with sample projects for each environment manager type.
