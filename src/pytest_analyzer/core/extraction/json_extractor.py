"""
JSON result extractor for pytest_analyzer.

This module provides the JsonResultExtractor class that extracts test failures
from pytest's JSON output format. It parses JSON reports generated by the
pytest-json-report plugin and converts them into PytestFailure objects.
"""

import json
import logging
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

from ..errors import ExtractionError
from ..models.pytest_failure import PytestFailure
from .base import BaseExtractor

logger = logging.getLogger(__name__)


class JsonResultExtractor(BaseExtractor):
    """
    Extracts test failures from pytest JSON output.

    This class parses JSON reports generated by pytest (using the pytest-json-report plugin)
    and converts them into PytestFailure objects.
    """

    def _do_extract(self, json_path: Path) -> List[PytestFailure]:
        """
        Parse a JSON report file and extract test failures.

        Args:
            json_path: Path to the JSON report file

        Returns:
            List of PytestFailure objects

        Raises:
            ExtractionError: If JSON parsing fails
        """
        try:
            with json_path.open() as f:
                data = json.load(f)
            return self._extract_from_dict(data)
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in report file: {json_path}")
            raise ExtractionError(
                f"Invalid JSON format in {json_path}: {str(e)}"
            ) from e

    def _extract_from_dict(self, data: Dict[str, Any]) -> List[PytestFailure]:
        """
        Extract test failures from a parsed JSON dictionary.

        Args:
            data: Parsed JSON data (dictionary)

        Returns:
            List of PytestFailure objects
        """
        failures = []

        # Process test entries
        tests = data.get("tests", [])
        for test in tests:
            if test.get("outcome") == "failed":
                failure = self._create_failure_from_test(test)
                if failure:
                    failures.append(failure)

        return failures

    def _create_failure_from_test(
        self, test: Dict[str, Any]
    ) -> Optional[PytestFailure]:
        """
        Create a PytestFailure object from a test entry in the JSON report.

        Args:
            test: Test entry from the JSON report

        Returns:
            PytestFailure object, or None if test entry is empty or extraction fails
        """
        # Check if the test entry is empty or missing essential fields
        if not test or "nodeid" not in test:
            return None

        try:
            # Extract basic test information
            test_name = test.get("nodeid", "")

            # Extract file path and line number
            file_path = ""
            line_number = None

            # First, try to get file path from nodeid
            if test_name and "::" in test_name:
                file_part = test_name.split("::", 1)[0]
                file_path = str(self.path_resolver.resolve_path(file_part))

            # If nodeid doesn't have a file part, try the 'file' field
            if not file_path and "file" in test:
                file_path = str(self.path_resolver.resolve_path(test["file"]))

            # Extract line number
            if "line" in test:
                line_number = test["line"]

            # Extract error information
            error_type = test.get("outcome", "failed").capitalize()
            call_info = test.get("call", {})
            message = test.get("message", "")

            # First check exc_info as it's most reliable in test environment
            exc_info = call_info.get("exc_info", {})
            if exc_info and "type" in exc_info:
                error_type = exc_info["type"]
            # Next try to extract from message
            elif message:
                match = re.search(r"^(\w+Error):", message)
                if match:
                    error_type = match.group(1)
            # Finally check traceback
            elif call_info.get("traceback"):
                traceback_entry = call_info["traceback"][0]
                if isinstance(traceback_entry, dict) and "message" in traceback_entry:
                    traceback_message = traceback_entry.get("message", "")
                    match = re.search(r"^(\w+Error):", traceback_message)
                    if match:
                        error_type = match.group(1)

            # Extract error message
            error_message = ""
            if "message" in test:
                error_message = test["message"]
            elif "longrepr" in call_info:
                error_message = call_info["longrepr"]

            # Extract traceback
            traceback = ""
            if "traceback" in call_info:
                traceback_entries = call_info["traceback"]
                if isinstance(traceback_entries, list):
                    traceback = "\n".join(str(entry) for entry in traceback_entries)
                else:
                    traceback = str(traceback_entries)

            # Extract relevant code
            relevant_code = ""
            if "source" in call_info:
                relevant_code = call_info["source"]

            # Create PytestFailure object
            return PytestFailure(
                test_name=test_name,
                test_file=file_path,
                line_number=line_number,
                error_type=error_type,
                error_message=error_message,
                traceback=traceback,
                relevant_code=relevant_code,
                raw_output_section=json.dumps(test, indent=2),
            )

        except Exception as e:
            logger.error(f"Error creating PytestFailure from test entry: {e}")
            return None
