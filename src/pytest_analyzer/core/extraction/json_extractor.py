import json
import logging
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

from ...utils.path_resolver import PathResolver
from ...utils.resource_manager import ResourceMonitor, with_timeout
from ..models.pytest_failure import PytestFailure

logger = logging.getLogger(__name__)


class JsonResultExtractor:
    """
    Extracts test failures from pytest JSON output.

    This class parses JSON reports generated by pytest (using the pytest-json-report plugin)
    and converts them into PytestFailure objects.
    """

    def __init__(self, path_resolver: Optional[PathResolver] = None, timeout: int = 30):
        """
        Initialize the JSON extractor.

        Args:
            path_resolver: PathResolver instance for resolving file paths
            timeout: Timeout in seconds for extraction operations
        """
        self.path_resolver = path_resolver or PathResolver()
        self.timeout = timeout

    def extract(self, json_input: Any) -> Dict[str, Any]:
        """
        Extract test failures from pytest output following the Extractor protocol.

        Args:
            json_input: Path to the JSON report file or JSON data (str, Path, or dict)

        Returns:
            A dictionary containing extracted failures and metadata

        Raises:
            ExtractionError: If extraction fails
        """
        from ..errors import ExtractionError

        failures = []
        source = ""

        try:
            if isinstance(json_input, (str, Path)):
                path = Path(json_input)
                # Check for nonexistent file and raise ExtractionError directly
                if not path.exists():
                    logger.error(f"JSON report file not found: {path}")
                    raise ExtractionError(f"JSON report file not found: {path}")
                failures = self.extract_failures(path)
                source = str(path)
            elif isinstance(json_input, dict):
                failures = self._parse_json_data(json_input)
                source = "dict"
            else:
                raise TypeError(f"Unsupported input type: {type(json_input)}")

            return {
                "failures": failures,
                "format": "json",
                "count": len(failures),
                "source": source,
            }
        except Exception as e:
            logger.error(f"Error extracting from JSON: {e}")
            raise ExtractionError(f"Failed to extract from JSON: {e}") from e

    @with_timeout(30)
    def extract_failures(self, json_path: Path) -> List[PytestFailure]:
        """
        Extract test failures from a pytest JSON report.
        This method is backward compatible and returns an empty list on errors.

        Args:
            json_path: Path to the JSON report file

        Returns:
            List of PytestFailure objects
        """
        if not json_path.exists():
            logger.error(f"JSON report file not found: {json_path}")
            return []  # Return empty list for compatibility with existing code

        try:
            with ResourceMonitor(max_time_seconds=self.timeout):
                return self._parse_json_report(json_path)
        except Exception as e:
            logger.error(f"Error extracting failures from JSON report: {e}")
            return []

    def _parse_json_report(self, json_path: Path) -> List[PytestFailure]:
        """
        Parse a JSON report file and extract test failures.

        Args:
            json_path: Path to the JSON report file

        Returns:
            List of PytestFailure objects
        """
        with json_path.open() as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON in report file: {e}")
                return []

        failures = []

        # Process test entries
        tests = data.get("tests", [])
        for test in tests:
            if test.get("outcome") == "failed":
                failure = self._create_failure_from_test(test)
                if failure:
                    failures.append(failure)

        return failures

    def _create_failure_from_test(self, test: Dict[str, Any]) -> Optional[PytestFailure]:
        """
        Create a PytestFailure object from a test entry in the JSON report.

        Args:
            test: Test entry from the JSON report

        Returns:
            PytestFailure object, or None if test entry is empty or extraction fails
        """
        # Check if the test entry is empty or missing essential fields
        if not test or "nodeid" not in test:
            return None

        try:
            # Extract basic test information
            test_name = test.get("nodeid", "")

            # Extract file path and line number
            file_path = ""
            line_number = None

            # First, try to get file path from nodeid
            if test_name and "::" in test_name:
                file_part = test_name.split("::", 1)[0]
                file_path = str(self.path_resolver.resolve_path(file_part))

            # If nodeid doesn't have a file part, try the 'file' field
            if not file_path and "file" in test:
                file_path = str(self.path_resolver.resolve_path(test["file"]))

            # Extract line number
            if "line" in test:
                line_number = test["line"]

            # Extract error information
            error_type = test.get("outcome", "failed").capitalize()
            call_info = test.get("call", {})
            message = test.get("message", "")

            # First check exc_info as it's most reliable in test environment
            exc_info = call_info.get("exc_info", {})
            if exc_info and "type" in exc_info:
                error_type = exc_info["type"]
            # Next try to extract from message
            elif message:
                match = re.search(r"^(\w+Error):", message)
                if match:
                    error_type = match.group(1)
            # Finally check traceback
            elif call_info.get("traceback"):
                traceback_entry = call_info["traceback"][0]
                if isinstance(traceback_entry, dict) and "message" in traceback_entry:
                    traceback_message = traceback_entry.get("message", "")
                    match = re.search(r"^(\w+Error):", traceback_message)
                    if match:
                        error_type = match.group(1)

            # Extract error message
            error_message = ""
            if "message" in test:
                error_message = test["message"]
            elif "longrepr" in call_info:
                error_message = call_info["longrepr"]

            # Extract traceback
            traceback = ""
            if "traceback" in call_info:
                traceback_entries = call_info["traceback"]
                if isinstance(traceback_entries, list):
                    traceback = "\n".join(str(entry) for entry in traceback_entries)
                else:
                    traceback = str(traceback_entries)

            # Extract relevant code
            relevant_code = ""
            if "source" in call_info:
                relevant_code = call_info["source"]

            # Create PytestFailure object
            return PytestFailure(
                test_name=test_name,
                test_file=file_path,
                line_number=line_number,
                error_type=error_type,
                error_message=error_message,
                traceback=traceback,
                relevant_code=relevant_code,
                raw_output_section=json.dumps(test, indent=2),
            )

        except Exception as e:
            logger.error(f"Error creating PytestFailure from test entry: {e}")
            return None

    def _parse_json_data(self, data: Dict[str, Any]) -> List[PytestFailure]:
        """
        Parse JSON data directly and extract test failures.

        Args:
            data: JSON data as dictionary

        Returns:
            List of PytestFailure objects
        """
        failures = []

        # Process test entries
        tests = data.get("tests", [])
        for test in tests:
            if test.get("outcome") == "failed":
                failure = self._create_failure_from_test(test)
                if failure:
                    failures.append(failure)

        return failures
