import json
import logging
from pathlib import Path
from typing import List, Dict, Any, Optional

from ..models.test_failure import TestFailure
from ...utils.resource_manager import with_timeout, ResourceMonitor
from ...utils.path_resolver import PathResolver

logger = logging.getLogger(__name__)


class JsonResultExtractor:
    """
    Extracts test failures from pytest JSON output.
    
    This class parses JSON reports generated by pytest (using the pytest-json-report plugin)
    and converts them into TestFailure objects.
    """
    
    def __init__(self, path_resolver: Optional[PathResolver] = None, timeout: int = 30):
        """
        Initialize the JSON extractor.
        
        Args:
            path_resolver: PathResolver instance for resolving file paths
            timeout: Timeout in seconds for extraction operations
        """
        self.path_resolver = path_resolver or PathResolver()
        self.timeout = timeout
        
    @with_timeout(30)
    def extract_failures(self, json_path: Path) -> List[TestFailure]:
        """
        Extract test failures from a pytest JSON report.
        
        Args:
            json_path: Path to the JSON report file
            
        Returns:
            List of TestFailure objects
        """
        if not json_path.exists():
            logger.error(f"JSON report file not found: {json_path}")
            return []
            
        try:
            with ResourceMonitor(max_time_seconds=self.timeout):
                return self._parse_json_report(json_path)
        except Exception as e:
            logger.error(f"Error extracting failures from JSON report: {e}")
            return []
            
    def _parse_json_report(self, json_path: Path) -> List[TestFailure]:
        """
        Parse a JSON report file and extract test failures.
        
        Args:
            json_path: Path to the JSON report file
            
        Returns:
            List of TestFailure objects
        """
        with json_path.open() as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON in report file: {e}")
                return []
                
        failures = []
        
        # Process test entries
        tests = data.get('tests', [])
        for test in tests:
            if test.get('outcome') == 'failed':
                failure = self._create_failure_from_test(test)
                if failure:
                    failures.append(failure)
                    
        return failures
        
    def _create_failure_from_test(self, test: Dict[str, Any]) -> Optional[TestFailure]:
        """
        Create a TestFailure object from a test entry in the JSON report.
        
        Args:
            test: Test entry from the JSON report
            
        Returns:
            TestFailure object, or None if extraction fails
        """
        try:
            # Extract basic test information
            test_name = test.get('nodeid', '')
            
            # Extract file path and line number
            file_path = ""
            line_number = None
            
            # First, try to get file path from nodeid
            if test_name and '::' in test_name:
                file_part = test_name.split('::', 1)[0]
                file_path = str(self.path_resolver.resolve_path(file_part))
                
            # If nodeid doesn't have a file part, try the 'file' field
            if not file_path and 'file' in test:
                file_path = str(self.path_resolver.resolve_path(test['file']))
                
            # Extract line number
            if 'line' in test:
                line_number = test['line']
                
            # Extract error information
            error_type = test.get('outcome', 'failed').capitalize()
            call_info = test.get('call', {})
            
            # Look for a more specific error type
            exc_info = call_info.get('exc_info', {})
            if exc_info and 'type' in exc_info:
                error_type = exc_info['type']
                
            # Extract error message
            error_message = ""
            if 'message' in test:
                error_message = test['message']
            elif 'longrepr' in call_info:
                error_message = call_info['longrepr']
                
            # Extract traceback
            traceback = ""
            if 'traceback' in call_info:
                traceback_entries = call_info['traceback']
                if isinstance(traceback_entries, list):
                    traceback = "\n".join(str(entry) for entry in traceback_entries)
                else:
                    traceback = str(traceback_entries)
                    
            # Extract relevant code
            relevant_code = ""
            if 'source' in call_info:
                relevant_code = call_info['source']
                
            # Create TestFailure object
            return TestFailure(
                test_name=test_name,
                test_file=file_path,
                line_number=line_number,
                error_type=error_type,
                error_message=error_message,
                traceback=traceback,
                relevant_code=relevant_code,
                raw_output_section=json.dumps(test, indent=2)
            )
            
        except Exception as e:
            logger.error(f"Error creating TestFailure from test entry: {e}")
            return None