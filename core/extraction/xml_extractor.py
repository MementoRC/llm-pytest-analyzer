import logging
from pathlib import Path
from typing import List, Optional
import xml.etree.ElementTree as ET

from ..models.test_failure import TestFailure
from ...utils.resource_manager import with_timeout, ResourceMonitor
from ...utils.path_resolver import PathResolver

logger = logging.getLogger(__name__)


class XmlResultExtractor:
    """
    Extracts test failures from pytest JUnit XML output.
    
    This class parses XML reports generated by pytest (using the --junit-xml option)
    and converts them into TestFailure objects.
    """
    
    def __init__(self, path_resolver: Optional[PathResolver] = None, timeout: int = 30):
        """
        Initialize the XML extractor.
        
        Args:
            path_resolver: PathResolver instance for resolving file paths
            timeout: Timeout in seconds for extraction operations
        """
        self.path_resolver = path_resolver or PathResolver()
        self.timeout = timeout
        
    @with_timeout(30)
    def extract_failures(self, xml_path: Path) -> List[TestFailure]:
        """
        Extract test failures from a pytest XML report.
        
        Args:
            xml_path: Path to the XML report file
            
        Returns:
            List of TestFailure objects
        """
        if not xml_path.exists():
            logger.error(f"XML report file not found: {xml_path}")
            return []
            
        try:
            with ResourceMonitor(max_time_seconds=self.timeout):
                return self._parse_xml_report(xml_path)
        except Exception as e:
            logger.error(f"Error extracting failures from XML report: {e}")
            return []
            
    def _parse_xml_report(self, xml_path: Path) -> List[TestFailure]:
        """
        Parse an XML report file and extract test failures.
        
        Args:
            xml_path: Path to the XML report file
            
        Returns:
            List of TestFailure objects
        """
        try:
            tree = ET.parse(xml_path)
            root = tree.getroot()
        except ET.ParseError as e:
            logger.error(f"Invalid XML in report file: {e}")
            return []
            
        failures = []
        
        # Find all testcase elements
        for testcase in root.findall('.//testcase'):
            # Check if the testcase has failure or error elements
            failure_elements = testcase.findall('failure')
            error_elements = testcase.findall('error')
            
            if failure_elements or error_elements:
                # Get failure information
                if failure_elements:
                    failure_element = failure_elements[0]
                    error_type = failure_element.get('type', 'Failure')
                    error_message = failure_element.get('message', '')
                    traceback = failure_element.text or ''
                elif error_elements:
                    error_element = error_elements[0]
                    error_type = error_element.get('type', 'Error')
                    error_message = error_element.get('message', '')
                    traceback = error_element.text or ''
                else:
                    continue  # Should not happen, but just in case
                    
                # Extract test information
                test_name = testcase.get('name', '')
                classname = testcase.get('classname', '')
                
                # Create a full test name
                full_test_name = f"{classname}.{test_name}" if classname else test_name
                
                # Extract file path and line number
                file_path = ""
                line_number = None
                
                # Try to extract file path from classname
                if classname and '.' in classname:
                    file_part = classname.replace('.', '/') + '.py'
                    file_path = str(self.path_resolver.resolve_path(file_part))
                    
                # Extract line number from traceback if available
                if traceback:
                    line_number = self._extract_line_number_from_traceback(traceback)
                    
                # Create TestFailure object
                failure = TestFailure(
                    test_name=full_test_name,
                    test_file=file_path,
                    line_number=line_number,
                    error_type=error_type,
                    error_message=error_message,
                    traceback=traceback,
                    raw_output_section=ET.tostring(testcase, encoding='unicode')
                )
                
                failures.append(failure)
                
        return failures
        
    def _extract_line_number_from_traceback(self, traceback: str) -> Optional[int]:
        """
        Extract line number from traceback text.
        
        Args:
            traceback: Traceback text
            
        Returns:
            Line number if found, None otherwise
        """
        import re
        
        # Look for "line X" or "line X," patterns in the traceback
        line_matches = re.findall(r'line\s+(\d+)', traceback)
        
        if line_matches:
            try:
                # Use the last line number in the traceback
                return int(line_matches[-1])
            except ValueError:
                pass
                
        return None